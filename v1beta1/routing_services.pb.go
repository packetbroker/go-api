// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: packetbroker/api/v1beta1/routing_services.proto

package packetbroker

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GetDefaultRoutingPolicyRequest struct {
	// LoRa Alliance NetID of the Forwarder Member.
	ForwarderNetId uint32 `protobuf:"varint,1,opt,name=forwarder_net_id,json=forwarderNetId,proto3" json:"forwarder_net_id,omitempty"`
	// Forwarder identifier issued by the Forwarder Member.
	ForwarderId string `protobuf:"bytes,2,opt,name=forwarder_id,json=forwarderId,proto3" json:"forwarder_id,omitempty"`
}

func (m *GetDefaultRoutingPolicyRequest) Reset()         { *m = GetDefaultRoutingPolicyRequest{} }
func (m *GetDefaultRoutingPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*GetDefaultRoutingPolicyRequest) ProtoMessage()    {}
func (*GetDefaultRoutingPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{0}
}
func (m *GetDefaultRoutingPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDefaultRoutingPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDefaultRoutingPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDefaultRoutingPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDefaultRoutingPolicyRequest.Merge(m, src)
}
func (m *GetDefaultRoutingPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetDefaultRoutingPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDefaultRoutingPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetDefaultRoutingPolicyRequest proto.InternalMessageInfo

func (m *GetDefaultRoutingPolicyRequest) GetForwarderNetId() uint32 {
	if m != nil {
		return m.ForwarderNetId
	}
	return 0
}

func (m *GetDefaultRoutingPolicyRequest) GetForwarderId() string {
	if m != nil {
		return m.ForwarderId
	}
	return ""
}

type SetDefaultRoutingPolicyRequest struct {
	// LoRa Alliance NetID of the Forwarder Member.
	ForwarderNetId uint32 `protobuf:"varint,1,opt,name=forwarder_net_id,json=forwarderNetId,proto3" json:"forwarder_net_id,omitempty"`
	// Forwarder identifier issued by the Forwarder Member.
	ForwarderId string `protobuf:"bytes,2,opt,name=forwarder_id,json=forwarderId,proto3" json:"forwarder_id,omitempty"`
	// New default Routing Policy.
	Policy *RoutingPolicy `protobuf:"bytes,3,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (m *SetDefaultRoutingPolicyRequest) Reset()         { *m = SetDefaultRoutingPolicyRequest{} }
func (m *SetDefaultRoutingPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*SetDefaultRoutingPolicyRequest) ProtoMessage()    {}
func (*SetDefaultRoutingPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{1}
}
func (m *SetDefaultRoutingPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDefaultRoutingPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDefaultRoutingPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetDefaultRoutingPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDefaultRoutingPolicyRequest.Merge(m, src)
}
func (m *SetDefaultRoutingPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetDefaultRoutingPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDefaultRoutingPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetDefaultRoutingPolicyRequest proto.InternalMessageInfo

func (m *SetDefaultRoutingPolicyRequest) GetForwarderNetId() uint32 {
	if m != nil {
		return m.ForwarderNetId
	}
	return 0
}

func (m *SetDefaultRoutingPolicyRequest) GetForwarderId() string {
	if m != nil {
		return m.ForwarderId
	}
	return ""
}

func (m *SetDefaultRoutingPolicyRequest) GetPolicy() *RoutingPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type GetHomeNetworkRoutingPolicyRequest struct {
	// LoRa Alliance NetID of the Forwarder Member.
	ForwarderNetId uint32 `protobuf:"varint,1,opt,name=forwarder_net_id,json=forwarderNetId,proto3" json:"forwarder_net_id,omitempty"`
	// Forwarder identifier issued by the Forwarder Member.
	ForwarderId string `protobuf:"bytes,2,opt,name=forwarder_id,json=forwarderId,proto3" json:"forwarder_id,omitempty"`
	// LoRa Alliance NetID of the Home Network Member.
	HomeNetworkNetId uint32 `protobuf:"varint,3,opt,name=home_network_net_id,json=homeNetworkNetId,proto3" json:"home_network_net_id,omitempty"`
}

func (m *GetHomeNetworkRoutingPolicyRequest) Reset()         { *m = GetHomeNetworkRoutingPolicyRequest{} }
func (m *GetHomeNetworkRoutingPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*GetHomeNetworkRoutingPolicyRequest) ProtoMessage()    {}
func (*GetHomeNetworkRoutingPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{2}
}
func (m *GetHomeNetworkRoutingPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHomeNetworkRoutingPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHomeNetworkRoutingPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHomeNetworkRoutingPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHomeNetworkRoutingPolicyRequest.Merge(m, src)
}
func (m *GetHomeNetworkRoutingPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetHomeNetworkRoutingPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHomeNetworkRoutingPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetHomeNetworkRoutingPolicyRequest proto.InternalMessageInfo

func (m *GetHomeNetworkRoutingPolicyRequest) GetForwarderNetId() uint32 {
	if m != nil {
		return m.ForwarderNetId
	}
	return 0
}

func (m *GetHomeNetworkRoutingPolicyRequest) GetForwarderId() string {
	if m != nil {
		return m.ForwarderId
	}
	return ""
}

func (m *GetHomeNetworkRoutingPolicyRequest) GetHomeNetworkNetId() uint32 {
	if m != nil {
		return m.HomeNetworkNetId
	}
	return 0
}

type SetHomeNetworkRoutingPolicyRequest struct {
	// LoRa Alliance NetID of the Forwarder Member.
	ForwarderNetId uint32 `protobuf:"varint,1,opt,name=forwarder_net_id,json=forwarderNetId,proto3" json:"forwarder_net_id,omitempty"`
	// Forwarder identifier issued by the Forwarder Member.
	ForwarderId string `protobuf:"bytes,2,opt,name=forwarder_id,json=forwarderId,proto3" json:"forwarder_id,omitempty"`
	// LoRa Alliance NetID of the Home Network Member.
	HomeNetworkNetId uint32 `protobuf:"varint,3,opt,name=home_network_net_id,json=homeNetworkNetId,proto3" json:"home_network_net_id,omitempty"`
	// New Routing Policy for the Home Network Member.
	Policy *RoutingPolicy `protobuf:"bytes,4,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (m *SetHomeNetworkRoutingPolicyRequest) Reset()         { *m = SetHomeNetworkRoutingPolicyRequest{} }
func (m *SetHomeNetworkRoutingPolicyRequest) String() string { return proto.CompactTextString(m) }
func (*SetHomeNetworkRoutingPolicyRequest) ProtoMessage()    {}
func (*SetHomeNetworkRoutingPolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{3}
}
func (m *SetHomeNetworkRoutingPolicyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetHomeNetworkRoutingPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetHomeNetworkRoutingPolicyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetHomeNetworkRoutingPolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetHomeNetworkRoutingPolicyRequest.Merge(m, src)
}
func (m *SetHomeNetworkRoutingPolicyRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetHomeNetworkRoutingPolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetHomeNetworkRoutingPolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetHomeNetworkRoutingPolicyRequest proto.InternalMessageInfo

func (m *SetHomeNetworkRoutingPolicyRequest) GetForwarderNetId() uint32 {
	if m != nil {
		return m.ForwarderNetId
	}
	return 0
}

func (m *SetHomeNetworkRoutingPolicyRequest) GetForwarderId() string {
	if m != nil {
		return m.ForwarderId
	}
	return ""
}

func (m *SetHomeNetworkRoutingPolicyRequest) GetHomeNetworkNetId() uint32 {
	if m != nil {
		return m.HomeNetworkNetId
	}
	return 0
}

func (m *SetHomeNetworkRoutingPolicyRequest) GetPolicy() *RoutingPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type GetRoutingPolicyResponse struct {
	Policy *RoutingPolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (m *GetRoutingPolicyResponse) Reset()         { *m = GetRoutingPolicyResponse{} }
func (m *GetRoutingPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*GetRoutingPolicyResponse) ProtoMessage()    {}
func (*GetRoutingPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{4}
}
func (m *GetRoutingPolicyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRoutingPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRoutingPolicyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRoutingPolicyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRoutingPolicyResponse.Merge(m, src)
}
func (m *GetRoutingPolicyResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRoutingPolicyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRoutingPolicyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRoutingPolicyResponse proto.InternalMessageInfo

func (m *GetRoutingPolicyResponse) GetPolicy() *RoutingPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type PublishUplinkMessageRequest struct {
	// LoRa Alliance NetID of the Forwarder Member.
	ForwarderNetId uint32 `protobuf:"varint,1,opt,name=forwarder_net_id,json=forwarderNetId,proto3" json:"forwarder_net_id,omitempty"`
	// Forwarder identifier issued by the Forwarder Member.
	ForwarderId string `protobuf:"bytes,2,opt,name=forwarder_id,json=forwarderId,proto3" json:"forwarder_id,omitempty"`
	// Uplink message to publish.
	Message *UplinkMessage `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PublishUplinkMessageRequest) Reset()         { *m = PublishUplinkMessageRequest{} }
func (m *PublishUplinkMessageRequest) String() string { return proto.CompactTextString(m) }
func (*PublishUplinkMessageRequest) ProtoMessage()    {}
func (*PublishUplinkMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{5}
}
func (m *PublishUplinkMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishUplinkMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishUplinkMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishUplinkMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishUplinkMessageRequest.Merge(m, src)
}
func (m *PublishUplinkMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *PublishUplinkMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishUplinkMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublishUplinkMessageRequest proto.InternalMessageInfo

func (m *PublishUplinkMessageRequest) GetForwarderNetId() uint32 {
	if m != nil {
		return m.ForwarderNetId
	}
	return 0
}

func (m *PublishUplinkMessageRequest) GetForwarderId() string {
	if m != nil {
		return m.ForwarderId
	}
	return ""
}

func (m *PublishUplinkMessageRequest) GetMessage() *UplinkMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type PublishUplinkMessageResponse struct {
	// Message identifier generated by the Router.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Delivery state of the uplink message.
	State MessageDeliveryState `protobuf:"varint,2,opt,name=state,proto3,enum=org.packetbroker.v1beta1.MessageDeliveryState" json:"state,omitempty"`
}

func (m *PublishUplinkMessageResponse) Reset()         { *m = PublishUplinkMessageResponse{} }
func (m *PublishUplinkMessageResponse) String() string { return proto.CompactTextString(m) }
func (*PublishUplinkMessageResponse) ProtoMessage()    {}
func (*PublishUplinkMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{6}
}
func (m *PublishUplinkMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishUplinkMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishUplinkMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishUplinkMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishUplinkMessageResponse.Merge(m, src)
}
func (m *PublishUplinkMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *PublishUplinkMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishUplinkMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PublishUplinkMessageResponse proto.InternalMessageInfo

func (m *PublishUplinkMessageResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PublishUplinkMessageResponse) GetState() MessageDeliveryState {
	if m != nil {
		return m.State
	}
	return MessageDeliveryState_ACCEPTED
}

type PublishDownlinkMessageRequest struct {
	// LoRa Alliance NetID of the Home Network Member.
	HomeNetworkNetId uint32 `protobuf:"varint,1,opt,name=home_network_net_id,json=homeNetworkNetId,proto3" json:"home_network_net_id,omitempty"`
	// LoRa Alliance NetID of the Forwarder Member.
	ForwarderNetId uint32 `protobuf:"varint,2,opt,name=forwarder_net_id,json=forwarderNetId,proto3" json:"forwarder_net_id,omitempty"`
	// Forwarder identifier issued by the Forwarder Member.
	// In LoRaWAN Class A downlink, this value must be copied from the RoutedUplinkMessage.
	// In LoRaWAN Class B or C downlink, this value is typically copied from a recent RoutedUplinkMessage.
	ForwarderId string `protobuf:"bytes,3,opt,name=forwarder_id,json=forwarderId,proto3" json:"forwarder_id,omitempty"`
	// Downlink message to publish.
	Message *DownlinkMessage `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PublishDownlinkMessageRequest) Reset()         { *m = PublishDownlinkMessageRequest{} }
func (m *PublishDownlinkMessageRequest) String() string { return proto.CompactTextString(m) }
func (*PublishDownlinkMessageRequest) ProtoMessage()    {}
func (*PublishDownlinkMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{7}
}
func (m *PublishDownlinkMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishDownlinkMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishDownlinkMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishDownlinkMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishDownlinkMessageRequest.Merge(m, src)
}
func (m *PublishDownlinkMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *PublishDownlinkMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishDownlinkMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublishDownlinkMessageRequest proto.InternalMessageInfo

func (m *PublishDownlinkMessageRequest) GetHomeNetworkNetId() uint32 {
	if m != nil {
		return m.HomeNetworkNetId
	}
	return 0
}

func (m *PublishDownlinkMessageRequest) GetForwarderNetId() uint32 {
	if m != nil {
		return m.ForwarderNetId
	}
	return 0
}

func (m *PublishDownlinkMessageRequest) GetForwarderId() string {
	if m != nil {
		return m.ForwarderId
	}
	return ""
}

func (m *PublishDownlinkMessageRequest) GetMessage() *DownlinkMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type PublishDownlinkMessageResponse struct {
	// Message identifier generated by the Router.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Delivery state of the downlink message.
	State MessageDeliveryState `protobuf:"varint,2,opt,name=state,proto3,enum=org.packetbroker.v1beta1.MessageDeliveryState" json:"state,omitempty"`
}

func (m *PublishDownlinkMessageResponse) Reset()         { *m = PublishDownlinkMessageResponse{} }
func (m *PublishDownlinkMessageResponse) String() string { return proto.CompactTextString(m) }
func (*PublishDownlinkMessageResponse) ProtoMessage()    {}
func (*PublishDownlinkMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{8}
}
func (m *PublishDownlinkMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishDownlinkMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishDownlinkMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishDownlinkMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishDownlinkMessageResponse.Merge(m, src)
}
func (m *PublishDownlinkMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *PublishDownlinkMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishDownlinkMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PublishDownlinkMessageResponse proto.InternalMessageInfo

func (m *PublishDownlinkMessageResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PublishDownlinkMessageResponse) GetState() MessageDeliveryState {
	if m != nil {
		return m.State
	}
	return MessageDeliveryState_ACCEPTED
}

type SubscribeForwarderRequest struct {
	// LoRa Alliance NetID of the Forwarder Member.
	ForwarderNetId uint32 `protobuf:"varint,1,opt,name=forwarder_net_id,json=forwarderNetId,proto3" json:"forwarder_net_id,omitempty"`
	// Forwarder identifier issued by the Forwarder Member.
	ForwarderId string `protobuf:"bytes,2,opt,name=forwarder_id,json=forwarderId,proto3" json:"forwarder_id,omitempty"`
	// Shared subscription group (optional).
	// Queue durability depends on the Router configuration.
	Group string `protobuf:"bytes,3,opt,name=group,proto3" json:"group,omitempty"`
}

func (m *SubscribeForwarderRequest) Reset()         { *m = SubscribeForwarderRequest{} }
func (m *SubscribeForwarderRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeForwarderRequest) ProtoMessage()    {}
func (*SubscribeForwarderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{9}
}
func (m *SubscribeForwarderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeForwarderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeForwarderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeForwarderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeForwarderRequest.Merge(m, src)
}
func (m *SubscribeForwarderRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeForwarderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeForwarderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeForwarderRequest proto.InternalMessageInfo

func (m *SubscribeForwarderRequest) GetForwarderNetId() uint32 {
	if m != nil {
		return m.ForwarderNetId
	}
	return 0
}

func (m *SubscribeForwarderRequest) GetForwarderId() string {
	if m != nil {
		return m.ForwarderId
	}
	return ""
}

func (m *SubscribeForwarderRequest) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

type SubscribeHomeNetworkRequest struct {
	// LoRa Alliance NetID of the Home Network Member.
	HomeNetworkNetId uint32 `protobuf:"varint,1,opt,name=home_network_net_id,json=homeNetworkNetId,proto3" json:"home_network_net_id,omitempty"`
	// Routing filters to configure the subscription.
	// A message gets delivered if any of the given filters pass.
	// If no filters are specified, all messages will be delivered.
	Filters []*RoutingFilter `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	// Shared subscription group (optional).
	// Queue durability depends on the Router configuration.
	Group string `protobuf:"bytes,3,opt,name=group,proto3" json:"group,omitempty"`
}

func (m *SubscribeHomeNetworkRequest) Reset()         { *m = SubscribeHomeNetworkRequest{} }
func (m *SubscribeHomeNetworkRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeHomeNetworkRequest) ProtoMessage()    {}
func (*SubscribeHomeNetworkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{10}
}
func (m *SubscribeHomeNetworkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeHomeNetworkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeHomeNetworkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeHomeNetworkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeHomeNetworkRequest.Merge(m, src)
}
func (m *SubscribeHomeNetworkRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeHomeNetworkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeHomeNetworkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeHomeNetworkRequest proto.InternalMessageInfo

func (m *SubscribeHomeNetworkRequest) GetHomeNetworkNetId() uint32 {
	if m != nil {
		return m.HomeNetworkNetId
	}
	return 0
}

func (m *SubscribeHomeNetworkRequest) GetFilters() []*RoutingFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *SubscribeHomeNetworkRequest) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

type RouteUplinkMessageRequest struct {
	// Uplink message to route.
	Message *RoutedUplinkMessage `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RouteUplinkMessageRequest) Reset()         { *m = RouteUplinkMessageRequest{} }
func (m *RouteUplinkMessageRequest) String() string { return proto.CompactTextString(m) }
func (*RouteUplinkMessageRequest) ProtoMessage()    {}
func (*RouteUplinkMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{11}
}
func (m *RouteUplinkMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteUplinkMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteUplinkMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteUplinkMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteUplinkMessageRequest.Merge(m, src)
}
func (m *RouteUplinkMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteUplinkMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteUplinkMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteUplinkMessageRequest proto.InternalMessageInfo

func (m *RouteUplinkMessageRequest) GetMessage() *RoutedUplinkMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type RouteDownlinkMessageRequest struct {
	// Downlink message to route.
	Message *RoutedDownlinkMessage `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RouteDownlinkMessageRequest) Reset()         { *m = RouteDownlinkMessageRequest{} }
func (m *RouteDownlinkMessageRequest) String() string { return proto.CompactTextString(m) }
func (*RouteDownlinkMessageRequest) ProtoMessage()    {}
func (*RouteDownlinkMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{12}
}
func (m *RouteDownlinkMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteDownlinkMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteDownlinkMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteDownlinkMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteDownlinkMessageRequest.Merge(m, src)
}
func (m *RouteDownlinkMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *RouteDownlinkMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteDownlinkMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteDownlinkMessageRequest proto.InternalMessageInfo

func (m *RouteDownlinkMessageRequest) GetMessage() *RoutedDownlinkMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type RouteMessageResponse struct {
	// Delivery state of the message.
	State MessageDeliveryState `protobuf:"varint,1,opt,name=state,proto3,enum=org.packetbroker.v1beta1.MessageDeliveryState" json:"state,omitempty"`
}

func (m *RouteMessageResponse) Reset()         { *m = RouteMessageResponse{} }
func (m *RouteMessageResponse) String() string { return proto.CompactTextString(m) }
func (*RouteMessageResponse) ProtoMessage()    {}
func (*RouteMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6946c2393187a47, []int{13}
}
func (m *RouteMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteMessageResponse.Merge(m, src)
}
func (m *RouteMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *RouteMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteMessageResponse proto.InternalMessageInfo

func (m *RouteMessageResponse) GetState() MessageDeliveryState {
	if m != nil {
		return m.State
	}
	return MessageDeliveryState_ACCEPTED
}

func init() {
	proto.RegisterType((*GetDefaultRoutingPolicyRequest)(nil), "org.packetbroker.v1beta1.GetDefaultRoutingPolicyRequest")
	proto.RegisterType((*SetDefaultRoutingPolicyRequest)(nil), "org.packetbroker.v1beta1.SetDefaultRoutingPolicyRequest")
	proto.RegisterType((*GetHomeNetworkRoutingPolicyRequest)(nil), "org.packetbroker.v1beta1.GetHomeNetworkRoutingPolicyRequest")
	proto.RegisterType((*SetHomeNetworkRoutingPolicyRequest)(nil), "org.packetbroker.v1beta1.SetHomeNetworkRoutingPolicyRequest")
	proto.RegisterType((*GetRoutingPolicyResponse)(nil), "org.packetbroker.v1beta1.GetRoutingPolicyResponse")
	proto.RegisterType((*PublishUplinkMessageRequest)(nil), "org.packetbroker.v1beta1.PublishUplinkMessageRequest")
	proto.RegisterType((*PublishUplinkMessageResponse)(nil), "org.packetbroker.v1beta1.PublishUplinkMessageResponse")
	proto.RegisterType((*PublishDownlinkMessageRequest)(nil), "org.packetbroker.v1beta1.PublishDownlinkMessageRequest")
	proto.RegisterType((*PublishDownlinkMessageResponse)(nil), "org.packetbroker.v1beta1.PublishDownlinkMessageResponse")
	proto.RegisterType((*SubscribeForwarderRequest)(nil), "org.packetbroker.v1beta1.SubscribeForwarderRequest")
	proto.RegisterType((*SubscribeHomeNetworkRequest)(nil), "org.packetbroker.v1beta1.SubscribeHomeNetworkRequest")
	proto.RegisterType((*RouteUplinkMessageRequest)(nil), "org.packetbroker.v1beta1.RouteUplinkMessageRequest")
	proto.RegisterType((*RouteDownlinkMessageRequest)(nil), "org.packetbroker.v1beta1.RouteDownlinkMessageRequest")
	proto.RegisterType((*RouteMessageResponse)(nil), "org.packetbroker.v1beta1.RouteMessageResponse")
}

func init() {
	proto.RegisterFile("packetbroker/api/v1beta1/routing_services.proto", fileDescriptor_d6946c2393187a47)
}

var fileDescriptor_d6946c2393187a47 = []byte{
	// 843 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x41, 0x4f, 0xdb, 0x48,
	0x14, 0x66, 0x92, 0x05, 0xc4, 0x63, 0x41, 0x91, 0xc9, 0xae, 0x82, 0xb3, 0x6b, 0x65, 0xad, 0xd5,
	0x92, 0x95, 0x16, 0x07, 0x82, 0xd8, 0x22, 0xb5, 0x52, 0x45, 0x9b, 0x92, 0x72, 0x00, 0xa1, 0x44,
	0xbd, 0xb4, 0x95, 0x90, 0x13, 0x4f, 0x1c, 0x2b, 0x4e, 0xc6, 0x1d, 0x8f, 0x83, 0xe8, 0x01, 0xf5,
	0x54, 0xf5, 0xd0, 0x43, 0x7f, 0x42, 0x2f, 0x3d, 0xb6, 0xbf, 0xa3, 0x47, 0x8e, 0x3d, 0x52, 0xf8,
	0x13, 0x3d, 0x55, 0x55, 0x6c, 0xc7, 0x71, 0x42, 0xc6, 0x21, 0xa9, 0x52, 0xf5, 0x82, 0x84, 0x67,
	0xde, 0x7b, 0xdf, 0xfb, 0xe6, 0x7b, 0xdf, 0x4c, 0x20, 0x67, 0xa9, 0xd5, 0x06, 0x66, 0x15, 0x4a,
	0x1a, 0x98, 0xe6, 0x54, 0xcb, 0xc8, 0xb5, 0x37, 0x2b, 0x98, 0xa9, 0x9b, 0x39, 0x4a, 0x1c, 0x66,
	0xb4, 0xf4, 0x63, 0x1b, 0xd3, 0xb6, 0x51, 0xc5, 0xb6, 0x62, 0x51, 0xc2, 0x88, 0x90, 0x22, 0x54,
	0x57, 0xc2, 0x41, 0x8a, 0x1f, 0x20, 0xa6, 0x75, 0x42, 0x74, 0x13, 0xe7, 0xdc, 0x7d, 0x15, 0xa7,
	0x96, 0xc3, 0x4d, 0x8b, 0x9d, 0x7a, 0x61, 0xe2, 0xdf, 0xdc, 0x3a, 0xb8, 0xe5, 0x34, 0xfd, 0xe4,
	0xe2, 0x1a, 0x77, 0x57, 0x13, 0xdb, 0xb6, 0xaa, 0x77, 0x51, 0x88, 0xff, 0x8c, 0x82, 0xed, 0xed,
	0x93, 0x9b, 0x20, 0x15, 0x31, 0x2b, 0xe0, 0x9a, 0xea, 0x98, 0xac, 0xe4, 0x2d, 0x1d, 0x11, 0xd3,
	0xa8, 0x9e, 0x96, 0xf0, 0x33, 0x07, 0xdb, 0x4c, 0xc8, 0x42, 0xa2, 0x46, 0xe8, 0x89, 0x4a, 0x35,
	0x4c, 0x8f, 0x5b, 0x98, 0x1d, 0x1b, 0x5a, 0x0a, 0x65, 0x50, 0x76, 0xa9, 0xb4, 0x1c, 0x7c, 0x3f,
	0xc4, 0x6c, 0x5f, 0x13, 0xfe, 0x82, 0x5f, 0x7b, 0x3b, 0x0d, 0x2d, 0x15, 0xcb, 0xa0, 0xec, 0x42,
	0x69, 0x31, 0xf8, 0xb6, 0xaf, 0xc9, 0x1f, 0x10, 0x48, 0xe5, 0x1f, 0x57, 0x4f, 0xb8, 0x0b, 0x73,
	0x96, 0x9b, 0x3d, 0x15, 0xcf, 0xa0, 0xec, 0x62, 0x7e, 0x4d, 0xe1, 0x9d, 0x8e, 0xd2, 0x0f, 0xc6,
	0x0f, 0x93, 0xdf, 0x22, 0x90, 0x8b, 0x98, 0x3d, 0x24, 0x4d, 0x7c, 0x88, 0xd9, 0x09, 0xa1, 0x8d,
	0xe9, 0x83, 0x5e, 0x87, 0x95, 0x3a, 0x69, 0xe2, 0x4e, 0x9e, 0x4e, 0xc1, 0x6e, 0xbe, 0xb8, 0x9b,
	0x2f, 0x51, 0xef, 0x41, 0x71, 0x33, 0xca, 0x9f, 0x11, 0xc8, 0xe5, 0x9f, 0x1a, 0x62, 0xe8, 0x18,
	0x7e, 0x99, 0xec, 0x18, 0x9e, 0x40, 0xaa, 0x88, 0x07, 0xf5, 0x62, 0x5b, 0xa4, 0x65, 0xe3, 0x50,
	0x72, 0x34, 0x59, 0xf2, 0xf7, 0x08, 0xd2, 0x47, 0x4e, 0xc5, 0x34, 0xec, 0xfa, 0x23, 0xcb, 0x34,
	0x5a, 0x8d, 0x03, 0x6f, 0x96, 0xa6, 0xc2, 0xdc, 0x2e, 0xcc, 0xfb, 0xa3, 0x3a, 0x5a, 0x92, 0xfd,
	0x68, 0xba, 0x71, 0x32, 0x83, 0x3f, 0x86, 0xc3, 0xf5, 0x09, 0x59, 0x86, 0x98, 0x8f, 0x70, 0xa1,
	0x14, 0x33, 0x34, 0xa1, 0x00, 0xb3, 0x36, 0x53, 0x19, 0x76, 0xe1, 0x2c, 0xe7, 0x15, 0x7e, 0x41,
	0x3f, 0x53, 0x01, 0x9b, 0x46, 0x1b, 0xd3, 0xd3, 0x72, 0x27, 0xaa, 0xe4, 0x05, 0xcb, 0x17, 0x08,
	0xfe, 0xf4, 0xcb, 0x16, 0xc8, 0x49, 0x6b, 0x08, 0x4f, 0x1c, 0x51, 0x20, 0x8e, 0x28, 0x86, 0xd1,
	0x1a, 0xbb, 0x11, 0xad, 0xf1, 0xeb, 0xb4, 0xde, 0xef, 0xd1, 0xea, 0x49, 0xec, 0x5f, 0x7e, 0x97,
	0x83, 0xf0, 0x03, 0x62, 0xdb, 0x20, 0xf1, 0x3a, 0x9c, 0x2a, 0xb5, 0x67, 0xb0, 0x5a, 0x76, 0x2a,
	0x76, 0x95, 0x1a, 0x15, 0xbc, 0xd7, 0x6d, 0x6a, 0x2a, 0xea, 0x4b, 0xc2, 0xac, 0x4e, 0x89, 0x63,
	0xf9, 0x14, 0x7a, 0xff, 0xc8, 0xef, 0x10, 0xa4, 0x03, 0x00, 0x61, 0x1f, 0x99, 0xec, 0x60, 0x77,
	0x61, 0xbe, 0x66, 0x98, 0x0c, 0x53, 0x3b, 0x15, 0xcb, 0xc4, 0x6f, 0x34, 0x91, 0x7b, 0xee, 0xfe,
	0x52, 0x37, 0x8e, 0x83, 0x53, 0x83, 0xd5, 0xce, 0x7e, 0x3c, 0x74, 0x4a, 0x8b, 0x3d, 0x05, 0x78,
	0x3e, 0xb0, 0x1e, 0x5d, 0x15, 0x6b, 0x9c, 0xf1, 0xaa, 0x43, 0xda, 0x5d, 0xe7, 0xa8, 0x7c, 0x7f,
	0xb0, 0x4e, 0x6e, 0x54, 0x1d, 0xae, 0xde, 0x9e, 0x42, 0xd2, 0xdd, 0x31, 0xa8, 0xb2, 0x40, 0x55,
	0xe8, 0x3b, 0x54, 0x95, 0xff, 0x12, 0xf7, 0xd2, 0x07, 0x86, 0x77, 0xa0, 0xb6, 0x54, 0x1d, 0x53,
	0xe1, 0x05, 0x82, 0x44, 0xef, 0xd2, 0xf7, 0xd6, 0x84, 0x1d, 0x7e, 0x91, 0xe8, 0x07, 0x82, 0x98,
	0x8f, 0x8c, 0x1c, 0xee, 0xd9, 0x1a, 0x24, 0xca, 0x63, 0x20, 0x88, 0x7e, 0x32, 0x88, 0xbf, 0x2b,
	0xde, 0xcb, 0x4a, 0xe9, 0xbe, 0xac, 0x94, 0x07, 0x9d, 0x97, 0x95, 0xf0, 0x0a, 0x41, 0xb2, 0xff,
	0xf2, 0xf6, 0x4b, 0xdd, 0x89, 0x84, 0x3c, 0xe2, 0x26, 0x9d, 0xa8, 0x61, 0x13, 0x92, 0xe5, 0x31,
	0x91, 0x8c, 0xbe, 0xd3, 0x79, 0x8d, 0xe7, 0x5f, 0xc6, 0x60, 0xc5, 0x55, 0x16, 0x0d, 0xec, 0xa4,
	0xa0, 0x32, 0x55, 0x78, 0x0e, 0xf3, 0xbe, 0xc1, 0x09, 0xdb, 0xfc, 0xc2, 0x11, 0x77, 0xa1, 0xf8,
	0xff, 0xb8, 0x61, 0x5e, 0xff, 0x1b, 0x48, 0xb0, 0x61, 0x21, 0xf0, 0x18, 0x61, 0x2b, 0xa2, 0x6d,
	0x9e, 0x13, 0x8a, 0xe3, 0x0e, 0xda, 0x06, 0xca, 0xbf, 0x8e, 0xc1, 0x6f, 0x1e, 0x11, 0x21, 0x2a,
	0x5d, 0x2a, 0xce, 0x7a, 0x54, 0xdc, 0x1a, 0xd9, 0xd3, 0x70, 0x2b, 0x10, 0x77, 0xc6, 0x0f, 0x1c,
	0x4e, 0xc7, 0xf6, 0x0d, 0xe8, 0xb8, 0xee, 0xcb, 0xe2, 0x78, 0x0e, 0xb7, 0x81, 0xf2, 0x5f, 0x11,
	0x24, 0x3c, 0x3a, 0xbc, 0xbf, 0x2e, 0x13, 0x14, 0x16, 0x43, 0xae, 0x1a, 0x75, 0x34, 0x5c, 0xf3,
	0x15, 0x95, 0x11, 0x41, 0x83, 0x0e, 0xd7, 0x86, 0xa5, 0x3e, 0x8f, 0x8d, 0x62, 0x20, 0xc2, 0x8c,
	0xc7, 0xad, 0x7b, 0x6f, 0xef, 0xe3, 0xa5, 0x84, 0xce, 0x2f, 0x25, 0x74, 0x71, 0x29, 0xa1, 0x37,
	0x57, 0xd2, 0xcc, 0xf9, 0x95, 0x34, 0xf3, 0xe9, 0x4a, 0x9a, 0x79, 0xfc, 0x9f, 0x4e, 0xfa, 0xf3,
	0x10, 0xaa, 0x87, 0x7f, 0x37, 0xdd, 0x0e, 0x2f, 0x56, 0xe6, 0xdc, 0x81, 0xdb, 0xfa, 0x16, 0x00,
	0x00, 0xff, 0xff, 0x7c, 0x8f, 0x0d, 0x07, 0x1e, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RoutingPolicyManagerClient is the client API for RoutingPolicyManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RoutingPolicyManagerClient interface {
	// Get the Default Routing Policy.
	GetDefaultPolicy(ctx context.Context, in *GetDefaultRoutingPolicyRequest, opts ...grpc.CallOption) (*GetRoutingPolicyResponse, error)
	// Set the Default Routing Policy.
	SetDefaultPolicy(ctx context.Context, in *SetDefaultRoutingPolicyRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// Get the Routing Policy with the Home Network.
	GetHomeNetworkPolicy(ctx context.Context, in *GetHomeNetworkRoutingPolicyRequest, opts ...grpc.CallOption) (*GetRoutingPolicyResponse, error)
	// Set the Routing Policy with the Home Network.
	SetHomeNetworkPolicy(ctx context.Context, in *SetHomeNetworkRoutingPolicyRequest, opts ...grpc.CallOption) (*types.Empty, error)
}

type routingPolicyManagerClient struct {
	cc *grpc.ClientConn
}

func NewRoutingPolicyManagerClient(cc *grpc.ClientConn) RoutingPolicyManagerClient {
	return &routingPolicyManagerClient{cc}
}

func (c *routingPolicyManagerClient) GetDefaultPolicy(ctx context.Context, in *GetDefaultRoutingPolicyRequest, opts ...grpc.CallOption) (*GetRoutingPolicyResponse, error) {
	out := new(GetRoutingPolicyResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v1beta1.RoutingPolicyManager/GetDefaultPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingPolicyManagerClient) SetDefaultPolicy(ctx context.Context, in *SetDefaultRoutingPolicyRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v1beta1.RoutingPolicyManager/SetDefaultPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingPolicyManagerClient) GetHomeNetworkPolicy(ctx context.Context, in *GetHomeNetworkRoutingPolicyRequest, opts ...grpc.CallOption) (*GetRoutingPolicyResponse, error) {
	out := new(GetRoutingPolicyResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v1beta1.RoutingPolicyManager/GetHomeNetworkPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingPolicyManagerClient) SetHomeNetworkPolicy(ctx context.Context, in *SetHomeNetworkRoutingPolicyRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v1beta1.RoutingPolicyManager/SetHomeNetworkPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutingPolicyManagerServer is the server API for RoutingPolicyManager service.
type RoutingPolicyManagerServer interface {
	// Get the Default Routing Policy.
	GetDefaultPolicy(context.Context, *GetDefaultRoutingPolicyRequest) (*GetRoutingPolicyResponse, error)
	// Set the Default Routing Policy.
	SetDefaultPolicy(context.Context, *SetDefaultRoutingPolicyRequest) (*types.Empty, error)
	// Get the Routing Policy with the Home Network.
	GetHomeNetworkPolicy(context.Context, *GetHomeNetworkRoutingPolicyRequest) (*GetRoutingPolicyResponse, error)
	// Set the Routing Policy with the Home Network.
	SetHomeNetworkPolicy(context.Context, *SetHomeNetworkRoutingPolicyRequest) (*types.Empty, error)
}

// UnimplementedRoutingPolicyManagerServer can be embedded to have forward compatible implementations.
type UnimplementedRoutingPolicyManagerServer struct {
}

func (*UnimplementedRoutingPolicyManagerServer) GetDefaultPolicy(ctx context.Context, req *GetDefaultRoutingPolicyRequest) (*GetRoutingPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultPolicy not implemented")
}
func (*UnimplementedRoutingPolicyManagerServer) SetDefaultPolicy(ctx context.Context, req *SetDefaultRoutingPolicyRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultPolicy not implemented")
}
func (*UnimplementedRoutingPolicyManagerServer) GetHomeNetworkPolicy(ctx context.Context, req *GetHomeNetworkRoutingPolicyRequest) (*GetRoutingPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHomeNetworkPolicy not implemented")
}
func (*UnimplementedRoutingPolicyManagerServer) SetHomeNetworkPolicy(ctx context.Context, req *SetHomeNetworkRoutingPolicyRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetHomeNetworkPolicy not implemented")
}

func RegisterRoutingPolicyManagerServer(s *grpc.Server, srv RoutingPolicyManagerServer) {
	s.RegisterService(&_RoutingPolicyManager_serviceDesc, srv)
}

func _RoutingPolicyManager_GetDefaultPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultRoutingPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).GetDefaultPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v1beta1.RoutingPolicyManager/GetDefaultPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).GetDefaultPolicy(ctx, req.(*GetDefaultRoutingPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingPolicyManager_SetDefaultPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDefaultRoutingPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).SetDefaultPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v1beta1.RoutingPolicyManager/SetDefaultPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).SetDefaultPolicy(ctx, req.(*SetDefaultRoutingPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingPolicyManager_GetHomeNetworkPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHomeNetworkRoutingPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).GetHomeNetworkPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v1beta1.RoutingPolicyManager/GetHomeNetworkPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).GetHomeNetworkPolicy(ctx, req.(*GetHomeNetworkRoutingPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingPolicyManager_SetHomeNetworkPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetHomeNetworkRoutingPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).SetHomeNetworkPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v1beta1.RoutingPolicyManager/SetHomeNetworkPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).SetHomeNetworkPolicy(ctx, req.(*SetHomeNetworkRoutingPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RoutingPolicyManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v1beta1.RoutingPolicyManager",
	HandlerType: (*RoutingPolicyManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDefaultPolicy",
			Handler:    _RoutingPolicyManager_GetDefaultPolicy_Handler,
		},
		{
			MethodName: "SetDefaultPolicy",
			Handler:    _RoutingPolicyManager_SetDefaultPolicy_Handler,
		},
		{
			MethodName: "GetHomeNetworkPolicy",
			Handler:    _RoutingPolicyManager_GetHomeNetworkPolicy_Handler,
		},
		{
			MethodName: "SetHomeNetworkPolicy",
			Handler:    _RoutingPolicyManager_SetHomeNetworkPolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "packetbroker/api/v1beta1/routing_services.proto",
}

// RouterForwarderDataClient is the client API for RouterForwarderData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouterForwarderDataClient interface {
	// Publish an uplink message. The return stream provides state updates of the message.
	// The server can close the stream at any time if there are no more updates available.
	Publish(ctx context.Context, in *PublishUplinkMessageRequest, opts ...grpc.CallOption) (RouterForwarderData_PublishClient, error)
	// Subscribe to routed downlink messages.
	Subscribe(ctx context.Context, in *SubscribeForwarderRequest, opts ...grpc.CallOption) (RouterForwarderData_SubscribeClient, error)
}

type routerForwarderDataClient struct {
	cc *grpc.ClientConn
}

func NewRouterForwarderDataClient(cc *grpc.ClientConn) RouterForwarderDataClient {
	return &routerForwarderDataClient{cc}
}

func (c *routerForwarderDataClient) Publish(ctx context.Context, in *PublishUplinkMessageRequest, opts ...grpc.CallOption) (RouterForwarderData_PublishClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RouterForwarderData_serviceDesc.Streams[0], "/org.packetbroker.v1beta1.RouterForwarderData/Publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerForwarderDataPublishClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouterForwarderData_PublishClient interface {
	Recv() (*PublishUplinkMessageResponse, error)
	grpc.ClientStream
}

type routerForwarderDataPublishClient struct {
	grpc.ClientStream
}

func (x *routerForwarderDataPublishClient) Recv() (*PublishUplinkMessageResponse, error) {
	m := new(PublishUplinkMessageResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerForwarderDataClient) Subscribe(ctx context.Context, in *SubscribeForwarderRequest, opts ...grpc.CallOption) (RouterForwarderData_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RouterForwarderData_serviceDesc.Streams[1], "/org.packetbroker.v1beta1.RouterForwarderData/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerForwarderDataSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouterForwarderData_SubscribeClient interface {
	Recv() (*RoutedDownlinkMessage, error)
	grpc.ClientStream
}

type routerForwarderDataSubscribeClient struct {
	grpc.ClientStream
}

func (x *routerForwarderDataSubscribeClient) Recv() (*RoutedDownlinkMessage, error) {
	m := new(RoutedDownlinkMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouterForwarderDataServer is the server API for RouterForwarderData service.
type RouterForwarderDataServer interface {
	// Publish an uplink message. The return stream provides state updates of the message.
	// The server can close the stream at any time if there are no more updates available.
	Publish(*PublishUplinkMessageRequest, RouterForwarderData_PublishServer) error
	// Subscribe to routed downlink messages.
	Subscribe(*SubscribeForwarderRequest, RouterForwarderData_SubscribeServer) error
}

// UnimplementedRouterForwarderDataServer can be embedded to have forward compatible implementations.
type UnimplementedRouterForwarderDataServer struct {
}

func (*UnimplementedRouterForwarderDataServer) Publish(req *PublishUplinkMessageRequest, srv RouterForwarderData_PublishServer) error {
	return status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (*UnimplementedRouterForwarderDataServer) Subscribe(req *SubscribeForwarderRequest, srv RouterForwarderData_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterRouterForwarderDataServer(s *grpc.Server, srv RouterForwarderDataServer) {
	s.RegisterService(&_RouterForwarderData_serviceDesc, srv)
}

func _RouterForwarderData_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PublishUplinkMessageRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterForwarderDataServer).Publish(m, &routerForwarderDataPublishServer{stream})
}

type RouterForwarderData_PublishServer interface {
	Send(*PublishUplinkMessageResponse) error
	grpc.ServerStream
}

type routerForwarderDataPublishServer struct {
	grpc.ServerStream
}

func (x *routerForwarderDataPublishServer) Send(m *PublishUplinkMessageResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RouterForwarderData_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeForwarderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterForwarderDataServer).Subscribe(m, &routerForwarderDataSubscribeServer{stream})
}

type RouterForwarderData_SubscribeServer interface {
	Send(*RoutedDownlinkMessage) error
	grpc.ServerStream
}

type routerForwarderDataSubscribeServer struct {
	grpc.ServerStream
}

func (x *routerForwarderDataSubscribeServer) Send(m *RoutedDownlinkMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _RouterForwarderData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v1beta1.RouterForwarderData",
	HandlerType: (*RouterForwarderDataServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _RouterForwarderData_Publish_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _RouterForwarderData_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "packetbroker/api/v1beta1/routing_services.proto",
}

// RouterHomeNetworkDataClient is the client API for RouterHomeNetworkData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouterHomeNetworkDataClient interface {
	// Publish a downlink message. The return stream provides state updates of the message.
	// The server can close the stream at any time if there are no more updates available.
	Publish(ctx context.Context, in *PublishDownlinkMessageRequest, opts ...grpc.CallOption) (RouterHomeNetworkData_PublishClient, error)
	// Subscribe to routed uplink messages.
	Subscribe(ctx context.Context, in *SubscribeHomeNetworkRequest, opts ...grpc.CallOption) (RouterHomeNetworkData_SubscribeClient, error)
}

type routerHomeNetworkDataClient struct {
	cc *grpc.ClientConn
}

func NewRouterHomeNetworkDataClient(cc *grpc.ClientConn) RouterHomeNetworkDataClient {
	return &routerHomeNetworkDataClient{cc}
}

func (c *routerHomeNetworkDataClient) Publish(ctx context.Context, in *PublishDownlinkMessageRequest, opts ...grpc.CallOption) (RouterHomeNetworkData_PublishClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RouterHomeNetworkData_serviceDesc.Streams[0], "/org.packetbroker.v1beta1.RouterHomeNetworkData/Publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerHomeNetworkDataPublishClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouterHomeNetworkData_PublishClient interface {
	Recv() (*PublishDownlinkMessageResponse, error)
	grpc.ClientStream
}

type routerHomeNetworkDataPublishClient struct {
	grpc.ClientStream
}

func (x *routerHomeNetworkDataPublishClient) Recv() (*PublishDownlinkMessageResponse, error) {
	m := new(PublishDownlinkMessageResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerHomeNetworkDataClient) Subscribe(ctx context.Context, in *SubscribeHomeNetworkRequest, opts ...grpc.CallOption) (RouterHomeNetworkData_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RouterHomeNetworkData_serviceDesc.Streams[1], "/org.packetbroker.v1beta1.RouterHomeNetworkData/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerHomeNetworkDataSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouterHomeNetworkData_SubscribeClient interface {
	Recv() (*RoutedUplinkMessage, error)
	grpc.ClientStream
}

type routerHomeNetworkDataSubscribeClient struct {
	grpc.ClientStream
}

func (x *routerHomeNetworkDataSubscribeClient) Recv() (*RoutedUplinkMessage, error) {
	m := new(RoutedUplinkMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouterHomeNetworkDataServer is the server API for RouterHomeNetworkData service.
type RouterHomeNetworkDataServer interface {
	// Publish a downlink message. The return stream provides state updates of the message.
	// The server can close the stream at any time if there are no more updates available.
	Publish(*PublishDownlinkMessageRequest, RouterHomeNetworkData_PublishServer) error
	// Subscribe to routed uplink messages.
	Subscribe(*SubscribeHomeNetworkRequest, RouterHomeNetworkData_SubscribeServer) error
}

// UnimplementedRouterHomeNetworkDataServer can be embedded to have forward compatible implementations.
type UnimplementedRouterHomeNetworkDataServer struct {
}

func (*UnimplementedRouterHomeNetworkDataServer) Publish(req *PublishDownlinkMessageRequest, srv RouterHomeNetworkData_PublishServer) error {
	return status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (*UnimplementedRouterHomeNetworkDataServer) Subscribe(req *SubscribeHomeNetworkRequest, srv RouterHomeNetworkData_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterRouterHomeNetworkDataServer(s *grpc.Server, srv RouterHomeNetworkDataServer) {
	s.RegisterService(&_RouterHomeNetworkData_serviceDesc, srv)
}

func _RouterHomeNetworkData_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PublishDownlinkMessageRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterHomeNetworkDataServer).Publish(m, &routerHomeNetworkDataPublishServer{stream})
}

type RouterHomeNetworkData_PublishServer interface {
	Send(*PublishDownlinkMessageResponse) error
	grpc.ServerStream
}

type routerHomeNetworkDataPublishServer struct {
	grpc.ServerStream
}

func (x *routerHomeNetworkDataPublishServer) Send(m *PublishDownlinkMessageResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RouterHomeNetworkData_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeHomeNetworkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterHomeNetworkDataServer).Subscribe(m, &routerHomeNetworkDataSubscribeServer{stream})
}

type RouterHomeNetworkData_SubscribeServer interface {
	Send(*RoutedUplinkMessage) error
	grpc.ServerStream
}

type routerHomeNetworkDataSubscribeServer struct {
	grpc.ServerStream
}

func (x *routerHomeNetworkDataSubscribeServer) Send(m *RoutedUplinkMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _RouterHomeNetworkData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v1beta1.RouterHomeNetworkData",
	HandlerType: (*RouterHomeNetworkDataServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _RouterHomeNetworkData_Publish_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _RouterHomeNetworkData_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "packetbroker/api/v1beta1/routing_services.proto",
}

// RouterRouterDataClient is the client API for RouterRouterData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouterRouterDataClient interface {
	// Route an uplink message.
	RouteUplink(ctx context.Context, in *RouteUplinkMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error)
	// Route a downlink message.
	RouteDownlink(ctx context.Context, in *RouteDownlinkMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error)
}

type routerRouterDataClient struct {
	cc *grpc.ClientConn
}

func NewRouterRouterDataClient(cc *grpc.ClientConn) RouterRouterDataClient {
	return &routerRouterDataClient{cc}
}

func (c *routerRouterDataClient) RouteUplink(ctx context.Context, in *RouteUplinkMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error) {
	out := new(RouteMessageResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v1beta1.RouterRouterData/RouteUplink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerRouterDataClient) RouteDownlink(ctx context.Context, in *RouteDownlinkMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error) {
	out := new(RouteMessageResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v1beta1.RouterRouterData/RouteDownlink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouterRouterDataServer is the server API for RouterRouterData service.
type RouterRouterDataServer interface {
	// Route an uplink message.
	RouteUplink(context.Context, *RouteUplinkMessageRequest) (*RouteMessageResponse, error)
	// Route a downlink message.
	RouteDownlink(context.Context, *RouteDownlinkMessageRequest) (*RouteMessageResponse, error)
}

// UnimplementedRouterRouterDataServer can be embedded to have forward compatible implementations.
type UnimplementedRouterRouterDataServer struct {
}

func (*UnimplementedRouterRouterDataServer) RouteUplink(ctx context.Context, req *RouteUplinkMessageRequest) (*RouteMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteUplink not implemented")
}
func (*UnimplementedRouterRouterDataServer) RouteDownlink(ctx context.Context, req *RouteDownlinkMessageRequest) (*RouteMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteDownlink not implemented")
}

func RegisterRouterRouterDataServer(s *grpc.Server, srv RouterRouterDataServer) {
	s.RegisterService(&_RouterRouterData_serviceDesc, srv)
}

func _RouterRouterData_RouteUplink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteUplinkMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterRouterDataServer).RouteUplink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v1beta1.RouterRouterData/RouteUplink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterRouterDataServer).RouteUplink(ctx, req.(*RouteUplinkMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterRouterData_RouteDownlink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteDownlinkMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterRouterDataServer).RouteDownlink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v1beta1.RouterRouterData/RouteDownlink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterRouterDataServer).RouteDownlink(ctx, req.(*RouteDownlinkMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RouterRouterData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v1beta1.RouterRouterData",
	HandlerType: (*RouterRouterDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RouteUplink",
			Handler:    _RouterRouterData_RouteUplink_Handler,
		},
		{
			MethodName: "RouteDownlink",
			Handler:    _RouterRouterData_RouteDownlink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "packetbroker/api/v1beta1/routing_services.proto",
}

func (m *GetDefaultRoutingPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDefaultRoutingPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDefaultRoutingPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForwarderId) > 0 {
		i -= len(m.ForwarderId)
		copy(dAtA[i:], m.ForwarderId)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.ForwarderId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ForwarderNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.ForwarderNetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetDefaultRoutingPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDefaultRoutingPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetDefaultRoutingPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ForwarderId) > 0 {
		i -= len(m.ForwarderId)
		copy(dAtA[i:], m.ForwarderId)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.ForwarderId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ForwarderNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.ForwarderNetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetHomeNetworkRoutingPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHomeNetworkRoutingPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHomeNetworkRoutingPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HomeNetworkNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.HomeNetworkNetId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ForwarderId) > 0 {
		i -= len(m.ForwarderId)
		copy(dAtA[i:], m.ForwarderId)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.ForwarderId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ForwarderNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.ForwarderNetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetHomeNetworkRoutingPolicyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetHomeNetworkRoutingPolicyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetHomeNetworkRoutingPolicyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.HomeNetworkNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.HomeNetworkNetId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ForwarderId) > 0 {
		i -= len(m.ForwarderId)
		copy(dAtA[i:], m.ForwarderId)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.ForwarderId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ForwarderNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.ForwarderNetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRoutingPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRoutingPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRoutingPolicyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublishUplinkMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishUplinkMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishUplinkMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ForwarderId) > 0 {
		i -= len(m.ForwarderId)
		copy(dAtA[i:], m.ForwarderId)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.ForwarderId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ForwarderNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.ForwarderNetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PublishUplinkMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishUplinkMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishUplinkMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublishDownlinkMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishDownlinkMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishDownlinkMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ForwarderId) > 0 {
		i -= len(m.ForwarderId)
		copy(dAtA[i:], m.ForwarderId)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.ForwarderId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ForwarderNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.ForwarderNetId))
		i--
		dAtA[i] = 0x10
	}
	if m.HomeNetworkNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.HomeNetworkNetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PublishDownlinkMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishDownlinkMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishDownlinkMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeForwarderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeForwarderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeForwarderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ForwarderId) > 0 {
		i -= len(m.ForwarderId)
		copy(dAtA[i:], m.ForwarderId)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.ForwarderId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ForwarderNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.ForwarderNetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeHomeNetworkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeHomeNetworkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeHomeNetworkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintRoutingServices(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoutingServices(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.HomeNetworkNetId != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.HomeNetworkNetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RouteUplinkMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteUplinkMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteUplinkMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteDownlinkMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteDownlinkMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteDownlinkMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoutingServices(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintRoutingServices(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRoutingServices(dAtA []byte, offset int, v uint64) int {
	offset -= sovRoutingServices(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetDefaultRoutingPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwarderNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.ForwarderNetId))
	}
	l = len(m.ForwarderId)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *SetDefaultRoutingPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwarderNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.ForwarderNetId))
	}
	l = len(m.ForwarderId)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *GetHomeNetworkRoutingPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwarderNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.ForwarderNetId))
	}
	l = len(m.ForwarderId)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	if m.HomeNetworkNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.HomeNetworkNetId))
	}
	return n
}

func (m *SetHomeNetworkRoutingPolicyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwarderNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.ForwarderNetId))
	}
	l = len(m.ForwarderId)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	if m.HomeNetworkNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.HomeNetworkNetId))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *GetRoutingPolicyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *PublishUplinkMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwarderNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.ForwarderNetId))
	}
	l = len(m.ForwarderId)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *PublishUplinkMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovRoutingServices(uint64(m.State))
	}
	return n
}

func (m *PublishDownlinkMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HomeNetworkNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.HomeNetworkNetId))
	}
	if m.ForwarderNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.ForwarderNetId))
	}
	l = len(m.ForwarderId)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *PublishDownlinkMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovRoutingServices(uint64(m.State))
	}
	return n
}

func (m *SubscribeForwarderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwarderNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.ForwarderNetId))
	}
	l = len(m.ForwarderId)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *SubscribeHomeNetworkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HomeNetworkNetId != 0 {
		n += 1 + sovRoutingServices(uint64(m.HomeNetworkNetId))
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovRoutingServices(uint64(l))
		}
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *RouteUplinkMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *RouteDownlinkMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovRoutingServices(uint64(l))
	}
	return n
}

func (m *RouteMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovRoutingServices(uint64(m.State))
	}
	return n
}

func sovRoutingServices(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRoutingServices(x uint64) (n int) {
	return sovRoutingServices(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetDefaultRoutingPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDefaultRoutingPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDefaultRoutingPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderNetId", wireType)
			}
			m.ForwarderNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwarderNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwarderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDefaultRoutingPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDefaultRoutingPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDefaultRoutingPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderNetId", wireType)
			}
			m.ForwarderNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwarderNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwarderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &RoutingPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHomeNetworkRoutingPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHomeNetworkRoutingPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHomeNetworkRoutingPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderNetId", wireType)
			}
			m.ForwarderNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwarderNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwarderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeNetworkNetId", wireType)
			}
			m.HomeNetworkNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeNetworkNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetHomeNetworkRoutingPolicyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetHomeNetworkRoutingPolicyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetHomeNetworkRoutingPolicyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderNetId", wireType)
			}
			m.ForwarderNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwarderNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwarderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeNetworkNetId", wireType)
			}
			m.HomeNetworkNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeNetworkNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &RoutingPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRoutingPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRoutingPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRoutingPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &RoutingPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishUplinkMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishUplinkMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishUplinkMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderNetId", wireType)
			}
			m.ForwarderNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwarderNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwarderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &UplinkMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishUplinkMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishUplinkMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishUplinkMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= MessageDeliveryState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishDownlinkMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishDownlinkMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishDownlinkMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeNetworkNetId", wireType)
			}
			m.HomeNetworkNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeNetworkNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderNetId", wireType)
			}
			m.ForwarderNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwarderNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwarderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &DownlinkMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishDownlinkMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishDownlinkMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishDownlinkMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= MessageDeliveryState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeForwarderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeForwarderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeForwarderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderNetId", wireType)
			}
			m.ForwarderNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForwarderNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwarderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwarderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeHomeNetworkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeHomeNetworkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeHomeNetworkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeNetworkNetId", wireType)
			}
			m.HomeNetworkNetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeNetworkNetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &RoutingFilter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteUplinkMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteUplinkMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteUplinkMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &RoutedUplinkMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteDownlinkMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteDownlinkMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteDownlinkMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoutingServices
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &RoutedDownlinkMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= MessageDeliveryState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoutingServices(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoutingServices
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoutingServices(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoutingServices
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoutingServices
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRoutingServices
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRoutingServices
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRoutingServices
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRoutingServices        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoutingServices          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRoutingServices = fmt.Errorf("proto: unexpected end of group")
)
