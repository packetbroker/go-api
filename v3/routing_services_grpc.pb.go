// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package packetbroker

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// TenantManagerClient is the client API for TenantManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantManagerClient interface {
	// List tenants.
	ListTenants(ctx context.Context, in *ListTenantsRequest, opts ...grpc.CallOption) (*ListTenantsResponse, error)
	// Get tenant.
	GetTenant(ctx context.Context, in *GetTenantRequest, opts ...grpc.CallOption) (*GetTenantResponse, error)
	// Set tenant.
	SetTenant(ctx context.Context, in *SetTenantRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Delete tenant.
	DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type tenantManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantManagerClient(cc grpc.ClientConnInterface) TenantManagerClient {
	return &tenantManagerClient{cc}
}

func (c *tenantManagerClient) ListTenants(ctx context.Context, in *ListTenantsRequest, opts ...grpc.CallOption) (*ListTenantsResponse, error) {
	out := new(ListTenantsResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.TenantManager/ListTenants", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManagerClient) GetTenant(ctx context.Context, in *GetTenantRequest, opts ...grpc.CallOption) (*GetTenantResponse, error) {
	out := new(GetTenantResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.TenantManager/GetTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManagerClient) SetTenant(ctx context.Context, in *SetTenantRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.TenantManager/SetTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManagerClient) DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.TenantManager/DeleteTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantManagerServer is the server API for TenantManager service.
// All implementations must embed UnimplementedTenantManagerServer
// for forward compatibility
type TenantManagerServer interface {
	// List tenants.
	ListTenants(context.Context, *ListTenantsRequest) (*ListTenantsResponse, error)
	// Get tenant.
	GetTenant(context.Context, *GetTenantRequest) (*GetTenantResponse, error)
	// Set tenant.
	SetTenant(context.Context, *SetTenantRequest) (*empty.Empty, error)
	// Delete tenant.
	DeleteTenant(context.Context, *DeleteTenantRequest) (*empty.Empty, error)
	mustEmbedUnimplementedTenantManagerServer()
}

// UnimplementedTenantManagerServer must be embedded to have forward compatible implementations.
type UnimplementedTenantManagerServer struct {
}

func (*UnimplementedTenantManagerServer) ListTenants(context.Context, *ListTenantsRequest) (*ListTenantsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTenants not implemented")
}
func (*UnimplementedTenantManagerServer) GetTenant(context.Context, *GetTenantRequest) (*GetTenantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTenant not implemented")
}
func (*UnimplementedTenantManagerServer) SetTenant(context.Context, *SetTenantRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTenant not implemented")
}
func (*UnimplementedTenantManagerServer) DeleteTenant(context.Context, *DeleteTenantRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTenant not implemented")
}
func (*UnimplementedTenantManagerServer) mustEmbedUnimplementedTenantManagerServer() {}

func RegisterTenantManagerServer(s *grpc.Server, srv TenantManagerServer) {
	s.RegisterService(&_TenantManager_serviceDesc, srv)
}

func _TenantManager_ListTenants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTenantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManagerServer).ListTenants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.TenantManager/ListTenants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManagerServer).ListTenants(ctx, req.(*ListTenantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManager_GetTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManagerServer).GetTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.TenantManager/GetTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManagerServer).GetTenant(ctx, req.(*GetTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManager_SetTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManagerServer).SetTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.TenantManager/SetTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManagerServer).SetTenant(ctx, req.(*SetTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManager_DeleteTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManagerServer).DeleteTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.TenantManager/DeleteTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManagerServer).DeleteTenant(ctx, req.(*DeleteTenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TenantManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v3.TenantManager",
	HandlerType: (*TenantManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListTenants",
			Handler:    _TenantManager_ListTenants_Handler,
		},
		{
			MethodName: "GetTenant",
			Handler:    _TenantManager_GetTenant_Handler,
		},
		{
			MethodName: "SetTenant",
			Handler:    _TenantManager_SetTenant_Handler,
		},
		{
			MethodName: "DeleteTenant",
			Handler:    _TenantManager_DeleteTenant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "packetbroker/api/v3/routing_services.proto",
}

// RoutingPolicyManagerClient is the client API for RoutingPolicyManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutingPolicyManagerClient interface {
	// Get the Default Routing Policy.
	GetDefaultPolicy(ctx context.Context, in *GetDefaultRoutingPolicyRequest, opts ...grpc.CallOption) (*GetRoutingPolicyResponse, error)
	// Set the Default Routing Policy.
	SetDefaultPolicy(ctx context.Context, in *SetRoutingPolicyRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// List the Routing Policies with Home Networks.
	ListHomeNetworkPolicies(ctx context.Context, in *ListHomeNetworkRoutingPoliciesRequest, opts ...grpc.CallOption) (*ListHomeNetworkRoutingPoliciesResponse, error)
	// Get the Routing Policy with the Home Network.
	GetHomeNetworkPolicy(ctx context.Context, in *GetHomeNetworkRoutingPolicyRequest, opts ...grpc.CallOption) (*GetRoutingPolicyResponse, error)
	// Set the Routing Policy with the Home Network.
	SetHomeNetworkPolicy(ctx context.Context, in *SetRoutingPolicyRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type routingPolicyManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutingPolicyManagerClient(cc grpc.ClientConnInterface) RoutingPolicyManagerClient {
	return &routingPolicyManagerClient{cc}
}

func (c *routingPolicyManagerClient) GetDefaultPolicy(ctx context.Context, in *GetDefaultRoutingPolicyRequest, opts ...grpc.CallOption) (*GetRoutingPolicyResponse, error) {
	out := new(GetRoutingPolicyResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RoutingPolicyManager/GetDefaultPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingPolicyManagerClient) SetDefaultPolicy(ctx context.Context, in *SetRoutingPolicyRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RoutingPolicyManager/SetDefaultPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingPolicyManagerClient) ListHomeNetworkPolicies(ctx context.Context, in *ListHomeNetworkRoutingPoliciesRequest, opts ...grpc.CallOption) (*ListHomeNetworkRoutingPoliciesResponse, error) {
	out := new(ListHomeNetworkRoutingPoliciesResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RoutingPolicyManager/ListHomeNetworkPolicies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingPolicyManagerClient) GetHomeNetworkPolicy(ctx context.Context, in *GetHomeNetworkRoutingPolicyRequest, opts ...grpc.CallOption) (*GetRoutingPolicyResponse, error) {
	out := new(GetRoutingPolicyResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RoutingPolicyManager/GetHomeNetworkPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingPolicyManagerClient) SetHomeNetworkPolicy(ctx context.Context, in *SetRoutingPolicyRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RoutingPolicyManager/SetHomeNetworkPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutingPolicyManagerServer is the server API for RoutingPolicyManager service.
// All implementations must embed UnimplementedRoutingPolicyManagerServer
// for forward compatibility
type RoutingPolicyManagerServer interface {
	// Get the Default Routing Policy.
	GetDefaultPolicy(context.Context, *GetDefaultRoutingPolicyRequest) (*GetRoutingPolicyResponse, error)
	// Set the Default Routing Policy.
	SetDefaultPolicy(context.Context, *SetRoutingPolicyRequest) (*empty.Empty, error)
	// List the Routing Policies with Home Networks.
	ListHomeNetworkPolicies(context.Context, *ListHomeNetworkRoutingPoliciesRequest) (*ListHomeNetworkRoutingPoliciesResponse, error)
	// Get the Routing Policy with the Home Network.
	GetHomeNetworkPolicy(context.Context, *GetHomeNetworkRoutingPolicyRequest) (*GetRoutingPolicyResponse, error)
	// Set the Routing Policy with the Home Network.
	SetHomeNetworkPolicy(context.Context, *SetRoutingPolicyRequest) (*empty.Empty, error)
	mustEmbedUnimplementedRoutingPolicyManagerServer()
}

// UnimplementedRoutingPolicyManagerServer must be embedded to have forward compatible implementations.
type UnimplementedRoutingPolicyManagerServer struct {
}

func (*UnimplementedRoutingPolicyManagerServer) GetDefaultPolicy(context.Context, *GetDefaultRoutingPolicyRequest) (*GetRoutingPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultPolicy not implemented")
}
func (*UnimplementedRoutingPolicyManagerServer) SetDefaultPolicy(context.Context, *SetRoutingPolicyRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultPolicy not implemented")
}
func (*UnimplementedRoutingPolicyManagerServer) ListHomeNetworkPolicies(context.Context, *ListHomeNetworkRoutingPoliciesRequest) (*ListHomeNetworkRoutingPoliciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHomeNetworkPolicies not implemented")
}
func (*UnimplementedRoutingPolicyManagerServer) GetHomeNetworkPolicy(context.Context, *GetHomeNetworkRoutingPolicyRequest) (*GetRoutingPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHomeNetworkPolicy not implemented")
}
func (*UnimplementedRoutingPolicyManagerServer) SetHomeNetworkPolicy(context.Context, *SetRoutingPolicyRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetHomeNetworkPolicy not implemented")
}
func (*UnimplementedRoutingPolicyManagerServer) mustEmbedUnimplementedRoutingPolicyManagerServer() {}

func RegisterRoutingPolicyManagerServer(s *grpc.Server, srv RoutingPolicyManagerServer) {
	s.RegisterService(&_RoutingPolicyManager_serviceDesc, srv)
}

func _RoutingPolicyManager_GetDefaultPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultRoutingPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).GetDefaultPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RoutingPolicyManager/GetDefaultPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).GetDefaultPolicy(ctx, req.(*GetDefaultRoutingPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingPolicyManager_SetDefaultPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRoutingPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).SetDefaultPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RoutingPolicyManager/SetDefaultPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).SetDefaultPolicy(ctx, req.(*SetRoutingPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingPolicyManager_ListHomeNetworkPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHomeNetworkRoutingPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).ListHomeNetworkPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RoutingPolicyManager/ListHomeNetworkPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).ListHomeNetworkPolicies(ctx, req.(*ListHomeNetworkRoutingPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingPolicyManager_GetHomeNetworkPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHomeNetworkRoutingPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).GetHomeNetworkPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RoutingPolicyManager/GetHomeNetworkPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).GetHomeNetworkPolicy(ctx, req.(*GetHomeNetworkRoutingPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingPolicyManager_SetHomeNetworkPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRoutingPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingPolicyManagerServer).SetHomeNetworkPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RoutingPolicyManager/SetHomeNetworkPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingPolicyManagerServer).SetHomeNetworkPolicy(ctx, req.(*SetRoutingPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RoutingPolicyManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v3.RoutingPolicyManager",
	HandlerType: (*RoutingPolicyManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDefaultPolicy",
			Handler:    _RoutingPolicyManager_GetDefaultPolicy_Handler,
		},
		{
			MethodName: "SetDefaultPolicy",
			Handler:    _RoutingPolicyManager_SetDefaultPolicy_Handler,
		},
		{
			MethodName: "ListHomeNetworkPolicies",
			Handler:    _RoutingPolicyManager_ListHomeNetworkPolicies_Handler,
		},
		{
			MethodName: "GetHomeNetworkPolicy",
			Handler:    _RoutingPolicyManager_GetHomeNetworkPolicy_Handler,
		},
		{
			MethodName: "SetHomeNetworkPolicy",
			Handler:    _RoutingPolicyManager_SetHomeNetworkPolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "packetbroker/api/v3/routing_services.proto",
}

// RouterForwarderDataClient is the client API for RouterForwarderData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RouterForwarderDataClient interface {
	// Publish an uplink message.
	Publish(ctx context.Context, in *PublishUplinkMessageRequest, opts ...grpc.CallOption) (*PublishUplinkMessageResponse, error)
	// Subscribe to routed downlink messages.
	Subscribe(ctx context.Context, in *SubscribeForwarderRequest, opts ...grpc.CallOption) (RouterForwarderData_SubscribeClient, error)
}

type routerForwarderDataClient struct {
	cc grpc.ClientConnInterface
}

func NewRouterForwarderDataClient(cc grpc.ClientConnInterface) RouterForwarderDataClient {
	return &routerForwarderDataClient{cc}
}

func (c *routerForwarderDataClient) Publish(ctx context.Context, in *PublishUplinkMessageRequest, opts ...grpc.CallOption) (*PublishUplinkMessageResponse, error) {
	out := new(PublishUplinkMessageResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RouterForwarderData/Publish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerForwarderDataClient) Subscribe(ctx context.Context, in *SubscribeForwarderRequest, opts ...grpc.CallOption) (RouterForwarderData_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RouterForwarderData_serviceDesc.Streams[0], "/org.packetbroker.v3.RouterForwarderData/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerForwarderDataSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouterForwarderData_SubscribeClient interface {
	Recv() (*RoutedDownlinkMessage, error)
	grpc.ClientStream
}

type routerForwarderDataSubscribeClient struct {
	grpc.ClientStream
}

func (x *routerForwarderDataSubscribeClient) Recv() (*RoutedDownlinkMessage, error) {
	m := new(RoutedDownlinkMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouterForwarderDataServer is the server API for RouterForwarderData service.
// All implementations must embed UnimplementedRouterForwarderDataServer
// for forward compatibility
type RouterForwarderDataServer interface {
	// Publish an uplink message.
	Publish(context.Context, *PublishUplinkMessageRequest) (*PublishUplinkMessageResponse, error)
	// Subscribe to routed downlink messages.
	Subscribe(*SubscribeForwarderRequest, RouterForwarderData_SubscribeServer) error
	mustEmbedUnimplementedRouterForwarderDataServer()
}

// UnimplementedRouterForwarderDataServer must be embedded to have forward compatible implementations.
type UnimplementedRouterForwarderDataServer struct {
}

func (*UnimplementedRouterForwarderDataServer) Publish(context.Context, *PublishUplinkMessageRequest) (*PublishUplinkMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (*UnimplementedRouterForwarderDataServer) Subscribe(*SubscribeForwarderRequest, RouterForwarderData_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedRouterForwarderDataServer) mustEmbedUnimplementedRouterForwarderDataServer() {}

func RegisterRouterForwarderDataServer(s *grpc.Server, srv RouterForwarderDataServer) {
	s.RegisterService(&_RouterForwarderData_serviceDesc, srv)
}

func _RouterForwarderData_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishUplinkMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterForwarderDataServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RouterForwarderData/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterForwarderDataServer).Publish(ctx, req.(*PublishUplinkMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterForwarderData_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeForwarderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterForwarderDataServer).Subscribe(m, &routerForwarderDataSubscribeServer{stream})
}

type RouterForwarderData_SubscribeServer interface {
	Send(*RoutedDownlinkMessage) error
	grpc.ServerStream
}

type routerForwarderDataSubscribeServer struct {
	grpc.ServerStream
}

func (x *routerForwarderDataSubscribeServer) Send(m *RoutedDownlinkMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _RouterForwarderData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v3.RouterForwarderData",
	HandlerType: (*RouterForwarderDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _RouterForwarderData_Publish_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _RouterForwarderData_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "packetbroker/api/v3/routing_services.proto",
}

// RouterHomeNetworkDataClient is the client API for RouterHomeNetworkData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RouterHomeNetworkDataClient interface {
	// Publish a downlink message.
	Publish(ctx context.Context, in *PublishDownlinkMessageRequest, opts ...grpc.CallOption) (*PublishDownlinkMessageResponse, error)
	// Subscribe to routed uplink messages.
	Subscribe(ctx context.Context, in *SubscribeHomeNetworkRequest, opts ...grpc.CallOption) (RouterHomeNetworkData_SubscribeClient, error)
}

type routerHomeNetworkDataClient struct {
	cc grpc.ClientConnInterface
}

func NewRouterHomeNetworkDataClient(cc grpc.ClientConnInterface) RouterHomeNetworkDataClient {
	return &routerHomeNetworkDataClient{cc}
}

func (c *routerHomeNetworkDataClient) Publish(ctx context.Context, in *PublishDownlinkMessageRequest, opts ...grpc.CallOption) (*PublishDownlinkMessageResponse, error) {
	out := new(PublishDownlinkMessageResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RouterHomeNetworkData/Publish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerHomeNetworkDataClient) Subscribe(ctx context.Context, in *SubscribeHomeNetworkRequest, opts ...grpc.CallOption) (RouterHomeNetworkData_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RouterHomeNetworkData_serviceDesc.Streams[0], "/org.packetbroker.v3.RouterHomeNetworkData/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerHomeNetworkDataSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RouterHomeNetworkData_SubscribeClient interface {
	Recv() (*RoutedUplinkMessage, error)
	grpc.ClientStream
}

type routerHomeNetworkDataSubscribeClient struct {
	grpc.ClientStream
}

func (x *routerHomeNetworkDataSubscribeClient) Recv() (*RoutedUplinkMessage, error) {
	m := new(RoutedUplinkMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouterHomeNetworkDataServer is the server API for RouterHomeNetworkData service.
// All implementations must embed UnimplementedRouterHomeNetworkDataServer
// for forward compatibility
type RouterHomeNetworkDataServer interface {
	// Publish a downlink message.
	Publish(context.Context, *PublishDownlinkMessageRequest) (*PublishDownlinkMessageResponse, error)
	// Subscribe to routed uplink messages.
	Subscribe(*SubscribeHomeNetworkRequest, RouterHomeNetworkData_SubscribeServer) error
	mustEmbedUnimplementedRouterHomeNetworkDataServer()
}

// UnimplementedRouterHomeNetworkDataServer must be embedded to have forward compatible implementations.
type UnimplementedRouterHomeNetworkDataServer struct {
}

func (*UnimplementedRouterHomeNetworkDataServer) Publish(context.Context, *PublishDownlinkMessageRequest) (*PublishDownlinkMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (*UnimplementedRouterHomeNetworkDataServer) Subscribe(*SubscribeHomeNetworkRequest, RouterHomeNetworkData_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedRouterHomeNetworkDataServer) mustEmbedUnimplementedRouterHomeNetworkDataServer() {
}

func RegisterRouterHomeNetworkDataServer(s *grpc.Server, srv RouterHomeNetworkDataServer) {
	s.RegisterService(&_RouterHomeNetworkData_serviceDesc, srv)
}

func _RouterHomeNetworkData_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishDownlinkMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterHomeNetworkDataServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RouterHomeNetworkData/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterHomeNetworkDataServer).Publish(ctx, req.(*PublishDownlinkMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterHomeNetworkData_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeHomeNetworkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterHomeNetworkDataServer).Subscribe(m, &routerHomeNetworkDataSubscribeServer{stream})
}

type RouterHomeNetworkData_SubscribeServer interface {
	Send(*RoutedUplinkMessage) error
	grpc.ServerStream
}

type routerHomeNetworkDataSubscribeServer struct {
	grpc.ServerStream
}

func (x *routerHomeNetworkDataSubscribeServer) Send(m *RoutedUplinkMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _RouterHomeNetworkData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v3.RouterHomeNetworkData",
	HandlerType: (*RouterHomeNetworkDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _RouterHomeNetworkData_Publish_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _RouterHomeNetworkData_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "packetbroker/api/v3/routing_services.proto",
}

// RouterRouterDataClient is the client API for RouterRouterData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RouterRouterDataClient interface {
	// Route an uplink message.
	RouteUplink(ctx context.Context, in *RouteUplinkMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error)
	// Route a downlink message.
	RouteDownlink(ctx context.Context, in *RouteDownlinkMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error)
}

type routerRouterDataClient struct {
	cc grpc.ClientConnInterface
}

func NewRouterRouterDataClient(cc grpc.ClientConnInterface) RouterRouterDataClient {
	return &routerRouterDataClient{cc}
}

func (c *routerRouterDataClient) RouteUplink(ctx context.Context, in *RouteUplinkMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error) {
	out := new(RouteMessageResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RouterRouterData/RouteUplink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routerRouterDataClient) RouteDownlink(ctx context.Context, in *RouteDownlinkMessageRequest, opts ...grpc.CallOption) (*RouteMessageResponse, error) {
	out := new(RouteMessageResponse)
	err := c.cc.Invoke(ctx, "/org.packetbroker.v3.RouterRouterData/RouteDownlink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouterRouterDataServer is the server API for RouterRouterData service.
// All implementations must embed UnimplementedRouterRouterDataServer
// for forward compatibility
type RouterRouterDataServer interface {
	// Route an uplink message.
	RouteUplink(context.Context, *RouteUplinkMessageRequest) (*RouteMessageResponse, error)
	// Route a downlink message.
	RouteDownlink(context.Context, *RouteDownlinkMessageRequest) (*RouteMessageResponse, error)
	mustEmbedUnimplementedRouterRouterDataServer()
}

// UnimplementedRouterRouterDataServer must be embedded to have forward compatible implementations.
type UnimplementedRouterRouterDataServer struct {
}

func (*UnimplementedRouterRouterDataServer) RouteUplink(context.Context, *RouteUplinkMessageRequest) (*RouteMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteUplink not implemented")
}
func (*UnimplementedRouterRouterDataServer) RouteDownlink(context.Context, *RouteDownlinkMessageRequest) (*RouteMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteDownlink not implemented")
}
func (*UnimplementedRouterRouterDataServer) mustEmbedUnimplementedRouterRouterDataServer() {}

func RegisterRouterRouterDataServer(s *grpc.Server, srv RouterRouterDataServer) {
	s.RegisterService(&_RouterRouterData_serviceDesc, srv)
}

func _RouterRouterData_RouteUplink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteUplinkMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterRouterDataServer).RouteUplink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RouterRouterData/RouteUplink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterRouterDataServer).RouteUplink(ctx, req.(*RouteUplinkMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouterRouterData_RouteDownlink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteDownlinkMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouterRouterDataServer).RouteDownlink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/org.packetbroker.v3.RouterRouterData/RouteDownlink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouterRouterDataServer).RouteDownlink(ctx, req.(*RouteDownlinkMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RouterRouterData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "org.packetbroker.v3.RouterRouterData",
	HandlerType: (*RouterRouterDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RouteUplink",
			Handler:    _RouterRouterData_RouteUplink_Handler,
		},
		{
			MethodName: "RouteDownlink",
			Handler:    _RouterRouterData_RouteDownlink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "packetbroker/api/v3/routing_services.proto",
}
