// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: packetbroker/api/v3/cluster.proto

package packetbroker

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ClusterAPIKey struct {
	// Unique identifier of the API key.
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// Cluster identifier.
	ClusterId string `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Network rights.
	Rights []Right `protobuf:"varint,3,rep,packed,name=rights,proto3,enum=org.packetbroker.v3.Right" json:"rights,omitempty"`
	// Last authentication timestamp.
	AuthenticatedAt *types.Timestamp `protobuf:"bytes,4,opt,name=authenticated_at,json=authenticatedAt,proto3" json:"authenticated_at,omitempty"`
	// Secret key value.
	Key string `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	// Key state.
	State                APIKeyState `protobuf:"varint,6,opt,name=state,proto3,enum=org.packetbroker.v3.APIKeyState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ClusterAPIKey) Reset()      { *m = ClusterAPIKey{} }
func (*ClusterAPIKey) ProtoMessage() {}
func (*ClusterAPIKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_aac1b3320d25b58c, []int{0}
}
func (m *ClusterAPIKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterAPIKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterAPIKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterAPIKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterAPIKey.Merge(m, src)
}
func (m *ClusterAPIKey) XXX_Size() int {
	return m.Size()
}
func (m *ClusterAPIKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterAPIKey.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterAPIKey proto.InternalMessageInfo

func (m *ClusterAPIKey) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *ClusterAPIKey) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ClusterAPIKey) GetRights() []Right {
	if m != nil {
		return m.Rights
	}
	return nil
}

func (m *ClusterAPIKey) GetAuthenticatedAt() *types.Timestamp {
	if m != nil {
		return m.AuthenticatedAt
	}
	return nil
}

func (m *ClusterAPIKey) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ClusterAPIKey) GetState() APIKeyState {
	if m != nil {
		return m.State
	}
	return APIKeyState_REQUESTED
}

func init() {
	proto.RegisterType((*ClusterAPIKey)(nil), "org.packetbroker.v3.ClusterAPIKey")
	golang_proto.RegisterType((*ClusterAPIKey)(nil), "org.packetbroker.v3.ClusterAPIKey")
}

func init() { proto.RegisterFile("packetbroker/api/v3/cluster.proto", fileDescriptor_aac1b3320d25b58c) }
func init() {
	golang_proto.RegisterFile("packetbroker/api/v3/cluster.proto", fileDescriptor_aac1b3320d25b58c)
}

var fileDescriptor_aac1b3320d25b58c = []byte{
	// 402 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x91, 0x3f, 0x68, 0xdb, 0x40,
	0x14, 0x87, 0xef, 0xc5, 0xb5, 0x20, 0x57, 0x9a, 0x06, 0x95, 0x82, 0x10, 0xf4, 0x45, 0xed, 0x52,
	0x4d, 0x27, 0x90, 0xa1, 0x4b, 0xa7, 0xb4, 0x74, 0x30, 0x5d, 0x8a, 0xda, 0xa9, 0x4b, 0x90, 0xad,
	0xab, 0x22, 0x14, 0xe7, 0x84, 0x74, 0x0a, 0x68, 0xcb, 0x18, 0x3a, 0x75, 0xec, 0x52, 0xe8, 0x98,
	0x31, 0x63, 0xc6, 0x8c, 0x19, 0x33, 0x66, 0xb4, 0xee, 0x16, 0x8f, 0x1e, 0x3d, 0x06, 0xfd, 0x31,
	0xd8, 0xe0, 0xed, 0x78, 0xef, 0x7b, 0x77, 0xdf, 0xef, 0x1e, 0x7d, 0x9b, 0x85, 0xd3, 0x94, 0xcb,
	0x49, 0x2e, 0x52, 0x9e, 0x7b, 0x61, 0x96, 0x78, 0x17, 0x23, 0x6f, 0x7a, 0x56, 0x16, 0x92, 0xe7,
	0x2c, 0xcb, 0x85, 0x14, 0xe6, 0x2b, 0x91, 0xc7, 0x6c, 0x13, 0x63, 0x17, 0x23, 0xfb, 0x28, 0x16,
	0x22, 0x3e, 0xe3, 0x5e, 0x8b, 0x4c, 0xca, 0x5f, 0x9e, 0x4c, 0x66, 0xbc, 0x90, 0xe1, 0x2c, 0xeb,
	0xa6, 0xec, 0xa3, 0x5d, 0x17, 0xf3, 0xf3, 0x72, 0x56, 0x74, 0xc0, 0xbb, 0xdf, 0x7b, 0xf4, 0xc5,
	0xe7, 0xee, 0xa1, 0xe3, 0x6f, 0xe3, 0xaf, 0xbc, 0x32, 0x5f, 0x53, 0x23, 0xe5, 0xd5, 0x49, 0x12,
	0x59, 0xe0, 0x80, 0xbb, 0x1f, 0x0c, 0x53, 0x5e, 0x8d, 0x23, 0xf3, 0x0d, 0xa5, 0xbd, 0x50, 0xd3,
	0xda, 0x6b, 0x5b, 0xfb, 0x7d, 0x65, 0x1c, 0x99, 0x3e, 0x35, 0xf2, 0x24, 0x3e, 0x95, 0x85, 0x35,
	0x70, 0x06, 0xee, 0x81, 0x6f, 0xb3, 0x1d, 0xbe, 0x2c, 0x68, 0x90, 0xa0, 0x27, 0xcd, 0x2f, 0xf4,
	0x30, 0x2c, 0xe5, 0x29, 0x3f, 0x97, 0xc9, 0x34, 0x94, 0x3c, 0x3a, 0x09, 0xa5, 0xf5, 0xcc, 0x01,
	0xf7, 0xb9, 0x6f, 0xb3, 0x2e, 0x18, 0x5b, 0x07, 0x63, 0x3f, 0xd6, 0xc1, 0x82, 0x97, 0x5b, 0x33,
	0xc7, 0xd2, 0x3c, 0xa4, 0x83, 0x94, 0x57, 0xd6, 0xb0, 0x55, 0x6a, 0x8e, 0xe6, 0x07, 0x3a, 0x2c,
	0x64, 0x28, 0xb9, 0x65, 0x38, 0xe0, 0x1e, 0xf8, 0xce, 0x4e, 0x97, 0x2e, 0xee, 0xf7, 0x86, 0x0b,
	0x3a, 0xfc, 0xd3, 0x3f, 0xb8, 0xaf, 0x11, 0x1e, 0x6a, 0x84, 0xc7, 0x1a, 0xc9, 0xbc, 0x46, 0xb2,
	0xa8, 0x91, 0x2c, 0x6b, 0x24, 0xab, 0x1a, 0xe1, 0x52, 0x21, 0x5c, 0x29, 0x24, 0xd7, 0x0a, 0xe1,
	0x46, 0x21, 0xb9, 0x55, 0x48, 0xee, 0x14, 0x92, 0x7b, 0x85, 0xf0, 0xa0, 0x10, 0x1e, 0x15, 0x92,
	0xb9, 0x42, 0x58, 0x28, 0x24, 0x4b, 0x85, 0xb0, 0x52, 0x48, 0x2e, 0x35, 0x92, 0x2b, 0x8d, 0xf0,
	0x47, 0x23, 0xf9, 0xab, 0x11, 0xfe, 0x6b, 0x24, 0xd7, 0x1a, 0xc9, 0x8d, 0x46, 0xb8, 0xd5, 0x08,
	0x77, 0x1a, 0xe1, 0xe7, 0xfb, 0x58, 0x6c, 0xdb, 0x89, 0x3c, 0xee, 0x77, 0xf5, 0x71, 0xb3, 0x3e,
	0x31, 0xda, 0xef, 0x18, 0x3d, 0x05, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x95, 0xa3, 0xaf, 0x2f, 0x02,
	0x00, 0x00,
}

func (this *ClusterAPIKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClusterAPIKey)
	if !ok {
		that2, ok := that.(ClusterAPIKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyId != that1.KeyId {
		return false
	}
	if this.ClusterId != that1.ClusterId {
		return false
	}
	if len(this.Rights) != len(that1.Rights) {
		return false
	}
	for i := range this.Rights {
		if this.Rights[i] != that1.Rights[i] {
			return false
		}
	}
	if !this.AuthenticatedAt.Equal(that1.AuthenticatedAt) {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (m *ClusterAPIKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterAPIKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterAPIKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintCluster(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x2a
	}
	if m.AuthenticatedAt != nil {
		{
			size, err := m.AuthenticatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCluster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Rights) > 0 {
		dAtA3 := make([]byte, len(m.Rights)*10)
		var j2 int
		for _, num := range m.Rights {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintCluster(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyId) > 0 {
		i -= len(m.KeyId)
		copy(dAtA[i:], m.KeyId)
		i = encodeVarintCluster(dAtA, i, uint64(len(m.KeyId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCluster(dAtA []byte, offset int, v uint64) int {
	offset -= sovCluster(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedClusterAPIKey(r randyCluster, easy bool) *ClusterAPIKey {
	this := &ClusterAPIKey{}
	this.KeyId = string(randStringCluster(r))
	this.ClusterId = string(randStringCluster(r))
	v1 := r.Intn(10)
	this.Rights = make([]Right, v1)
	for i := 0; i < v1; i++ {
		this.Rights[i] = Right([]int32{0, 1, 5, 6, 4, 7, 8, 9, 10, 11}[r.Intn(10)])
	}
	if r.Intn(5) != 0 {
		this.AuthenticatedAt = types.NewPopulatedTimestamp(r, easy)
	}
	this.Key = string(randStringCluster(r))
	this.State = APIKeyState([]int32{0, 1, 2}[r.Intn(3)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyCluster interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneCluster(r randyCluster) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringCluster(r randyCluster) string {
	v2 := r.Intn(100)
	tmps := make([]rune, v2)
	for i := 0; i < v2; i++ {
		tmps[i] = randUTF8RuneCluster(r)
	}
	return string(tmps)
}
func randUnrecognizedCluster(r randyCluster, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldCluster(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldCluster(dAtA []byte, r randyCluster, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateCluster(dAtA, uint64(key))
		v3 := r.Int63()
		if r.Intn(2) == 0 {
			v3 *= -1
		}
		dAtA = encodeVarintPopulateCluster(dAtA, uint64(v3))
	case 1:
		dAtA = encodeVarintPopulateCluster(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateCluster(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateCluster(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateCluster(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateCluster(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *ClusterAPIKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if len(m.Rights) > 0 {
		l = 0
		for _, e := range m.Rights {
			l += sovCluster(uint64(e))
		}
		n += 1 + sovCluster(uint64(l)) + l
	}
	if m.AuthenticatedAt != nil {
		l = m.AuthenticatedAt.Size()
		n += 1 + l + sovCluster(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCluster(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovCluster(uint64(m.State))
	}
	return n
}

func sovCluster(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCluster(x uint64) (n int) {
	return sovCluster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ClusterAPIKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClusterAPIKey{`,
		`KeyId:` + fmt.Sprintf("%v", this.KeyId) + `,`,
		`ClusterId:` + fmt.Sprintf("%v", this.ClusterId) + `,`,
		`Rights:` + fmt.Sprintf("%v", this.Rights) + `,`,
		`AuthenticatedAt:` + strings.Replace(fmt.Sprintf("%v", this.AuthenticatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCluster(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ClusterAPIKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterAPIKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterAPIKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v Right
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Right(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rights = append(m.Rights, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCluster
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCluster
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCluster
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Rights) == 0 {
					m.Rights = make([]Right, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Right
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCluster
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Right(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rights = append(m.Rights, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthenticatedAt == nil {
				m.AuthenticatedAt = &types.Timestamp{}
			}
			if err := m.AuthenticatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCluster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= APIKeyState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCluster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCluster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCluster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCluster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCluster
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCluster
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCluster
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCluster        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCluster          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCluster = fmt.Errorf("proto: unexpected end of group")
)
